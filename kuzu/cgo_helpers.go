// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 03 Jul 2024 16:02:13 PDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package kuzu

/*
#cgo LDFLAGS: -lkuzu
#include <kuzu.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocSystemConfigMemory allocates memory for type C.kuzu_system_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSystemConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSystemConfigValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSystemConfigValue = unsafe.Sizeof([1]C.kuzu_system_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SystemConfig) Ref() *C.kuzu_system_config {
	if x == nil {
		return nil
	}
	return x.ref49fc98ca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SystemConfig) Free() {
	if x != nil && x.allocs49fc98ca != nil {
		x.allocs49fc98ca.(*cgoAllocMap).Free()
		x.ref49fc98ca = nil
	}
}

// NewSystemConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSystemConfigRef(ref unsafe.Pointer) *SystemConfig {
	if ref == nil {
		return nil
	}
	obj := new(SystemConfig)
	obj.ref49fc98ca = (*C.kuzu_system_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SystemConfig) PassRef() (*C.kuzu_system_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49fc98ca != nil {
		return x.ref49fc98ca, nil
	}
	mem49fc98ca := allocSystemConfigMemory(1)
	ref49fc98ca := (*C.kuzu_system_config)(mem49fc98ca)
	allocs49fc98ca := new(cgoAllocMap)
	allocs49fc98ca.Add(mem49fc98ca)

	var cbuffer_pool_size_allocs *cgoAllocMap
	ref49fc98ca.buffer_pool_size, cbuffer_pool_size_allocs = (C.uint64_t)(x.BufferPoolSize), cgoAllocsUnknown
	allocs49fc98ca.Borrow(cbuffer_pool_size_allocs)

	var cmax_num_threads_allocs *cgoAllocMap
	ref49fc98ca.max_num_threads, cmax_num_threads_allocs = (C.uint64_t)(x.MaxNumThreads), cgoAllocsUnknown
	allocs49fc98ca.Borrow(cmax_num_threads_allocs)

	var cenable_compression_allocs *cgoAllocMap
	ref49fc98ca.enable_compression, cenable_compression_allocs = (C._Bool)(x.EnableCompression), cgoAllocsUnknown
	allocs49fc98ca.Borrow(cenable_compression_allocs)

	var cread_only_allocs *cgoAllocMap
	ref49fc98ca.read_only, cread_only_allocs = (C._Bool)(x.ReadOnly), cgoAllocsUnknown
	allocs49fc98ca.Borrow(cread_only_allocs)

	var cmax_db_size_allocs *cgoAllocMap
	ref49fc98ca.max_db_size, cmax_db_size_allocs = (C.uint64_t)(x.MaxDbSize), cgoAllocsUnknown
	allocs49fc98ca.Borrow(cmax_db_size_allocs)

	x.ref49fc98ca = ref49fc98ca
	x.allocs49fc98ca = allocs49fc98ca
	return ref49fc98ca, allocs49fc98ca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SystemConfig) PassValue() (C.kuzu_system_config, *cgoAllocMap) {
	if x.ref49fc98ca != nil {
		return *x.ref49fc98ca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SystemConfig) Deref() {
	if x.ref49fc98ca == nil {
		return
	}
	x.BufferPoolSize = (uint64)(x.ref49fc98ca.buffer_pool_size)
	x.MaxNumThreads = (uint64)(x.ref49fc98ca.max_num_threads)
	x.EnableCompression = (bool)(x.ref49fc98ca.enable_compression)
	x.ReadOnly = (bool)(x.ref49fc98ca.read_only)
	x.MaxDbSize = (uint64)(x.ref49fc98ca.max_db_size)
}

// allocDatabaseMemory allocates memory for type C.kuzu_database in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDatabaseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDatabaseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDatabaseValue = unsafe.Sizeof([1]C.kuzu_database{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Database) Ref() *C.kuzu_database {
	if x == nil {
		return nil
	}
	return x.ref57d0c6d0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Database) Free() {
	if x != nil && x.allocs57d0c6d0 != nil {
		x.allocs57d0c6d0.(*cgoAllocMap).Free()
		x.ref57d0c6d0 = nil
	}
}

// NewDatabaseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDatabaseRef(ref unsafe.Pointer) *Database {
	if ref == nil {
		return nil
	}
	obj := new(Database)
	obj.ref57d0c6d0 = (*C.kuzu_database)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Database) PassRef() (*C.kuzu_database, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref57d0c6d0 != nil {
		return x.ref57d0c6d0, nil
	}
	mem57d0c6d0 := allocDatabaseMemory(1)
	ref57d0c6d0 := (*C.kuzu_database)(mem57d0c6d0)
	allocs57d0c6d0 := new(cgoAllocMap)
	allocs57d0c6d0.Add(mem57d0c6d0)

	var c_database_allocs *cgoAllocMap
	ref57d0c6d0._database, c_database_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Database)), cgoAllocsUnknown
	allocs57d0c6d0.Borrow(c_database_allocs)

	x.ref57d0c6d0 = ref57d0c6d0
	x.allocs57d0c6d0 = allocs57d0c6d0
	return ref57d0c6d0, allocs57d0c6d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Database) PassValue() (C.kuzu_database, *cgoAllocMap) {
	if x.ref57d0c6d0 != nil {
		return *x.ref57d0c6d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Database) Deref() {
	if x.ref57d0c6d0 == nil {
		return
	}
	x.Database = (unsafe.Pointer)(unsafe.Pointer(x.ref57d0c6d0._database))
}

// allocConnectionMemory allocates memory for type C.kuzu_connection in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConnectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConnectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfConnectionValue = unsafe.Sizeof([1]C.kuzu_connection{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Connection) Ref() *C.kuzu_connection {
	if x == nil {
		return nil
	}
	return x.ref38ace366
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Connection) Free() {
	if x != nil && x.allocs38ace366 != nil {
		x.allocs38ace366.(*cgoAllocMap).Free()
		x.ref38ace366 = nil
	}
}

// NewConnectionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConnectionRef(ref unsafe.Pointer) *Connection {
	if ref == nil {
		return nil
	}
	obj := new(Connection)
	obj.ref38ace366 = (*C.kuzu_connection)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Connection) PassRef() (*C.kuzu_connection, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref38ace366 != nil {
		return x.ref38ace366, nil
	}
	mem38ace366 := allocConnectionMemory(1)
	ref38ace366 := (*C.kuzu_connection)(mem38ace366)
	allocs38ace366 := new(cgoAllocMap)
	allocs38ace366.Add(mem38ace366)

	var c_connection_allocs *cgoAllocMap
	ref38ace366._connection, c_connection_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Connection)), cgoAllocsUnknown
	allocs38ace366.Borrow(c_connection_allocs)

	x.ref38ace366 = ref38ace366
	x.allocs38ace366 = allocs38ace366
	return ref38ace366, allocs38ace366

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Connection) PassValue() (C.kuzu_connection, *cgoAllocMap) {
	if x.ref38ace366 != nil {
		return *x.ref38ace366, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Connection) Deref() {
	if x.ref38ace366 == nil {
		return
	}
	x.Connection = (unsafe.Pointer)(unsafe.Pointer(x.ref38ace366._connection))
}

// allocPreparedStatementMemory allocates memory for type C.kuzu_prepared_statement in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPreparedStatementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPreparedStatementValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPreparedStatementValue = unsafe.Sizeof([1]C.kuzu_prepared_statement{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PreparedStatement) Ref() *C.kuzu_prepared_statement {
	if x == nil {
		return nil
	}
	return x.ref7af57e99
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PreparedStatement) Free() {
	if x != nil && x.allocs7af57e99 != nil {
		x.allocs7af57e99.(*cgoAllocMap).Free()
		x.ref7af57e99 = nil
	}
}

// NewPreparedStatementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPreparedStatementRef(ref unsafe.Pointer) *PreparedStatement {
	if ref == nil {
		return nil
	}
	obj := new(PreparedStatement)
	obj.ref7af57e99 = (*C.kuzu_prepared_statement)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PreparedStatement) PassRef() (*C.kuzu_prepared_statement, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7af57e99 != nil {
		return x.ref7af57e99, nil
	}
	mem7af57e99 := allocPreparedStatementMemory(1)
	ref7af57e99 := (*C.kuzu_prepared_statement)(mem7af57e99)
	allocs7af57e99 := new(cgoAllocMap)
	allocs7af57e99.Add(mem7af57e99)

	var c_prepared_statement_allocs *cgoAllocMap
	ref7af57e99._prepared_statement, c_prepared_statement_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.PreparedStatement)), cgoAllocsUnknown
	allocs7af57e99.Borrow(c_prepared_statement_allocs)

	var c_bound_values_allocs *cgoAllocMap
	ref7af57e99._bound_values, c_bound_values_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.BoundValues)), cgoAllocsUnknown
	allocs7af57e99.Borrow(c_bound_values_allocs)

	x.ref7af57e99 = ref7af57e99
	x.allocs7af57e99 = allocs7af57e99
	return ref7af57e99, allocs7af57e99

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PreparedStatement) PassValue() (C.kuzu_prepared_statement, *cgoAllocMap) {
	if x.ref7af57e99 != nil {
		return *x.ref7af57e99, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PreparedStatement) Deref() {
	if x.ref7af57e99 == nil {
		return
	}
	x.PreparedStatement = (unsafe.Pointer)(unsafe.Pointer(x.ref7af57e99._prepared_statement))
	x.BoundValues = (unsafe.Pointer)(unsafe.Pointer(x.ref7af57e99._bound_values))
}

// allocQueryResultMemory allocates memory for type C.kuzu_query_result in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryResultMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryResultValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueryResultValue = unsafe.Sizeof([1]C.kuzu_query_result{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryResult) Ref() *C.kuzu_query_result {
	if x == nil {
		return nil
	}
	return x.ref96f12068
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryResult) Free() {
	if x != nil && x.allocs96f12068 != nil {
		x.allocs96f12068.(*cgoAllocMap).Free()
		x.ref96f12068 = nil
	}
}

// NewQueryResultRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryResultRef(ref unsafe.Pointer) *QueryResult {
	if ref == nil {
		return nil
	}
	obj := new(QueryResult)
	obj.ref96f12068 = (*C.kuzu_query_result)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryResult) PassRef() (*C.kuzu_query_result, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref96f12068 != nil {
		return x.ref96f12068, nil
	}
	mem96f12068 := allocQueryResultMemory(1)
	ref96f12068 := (*C.kuzu_query_result)(mem96f12068)
	allocs96f12068 := new(cgoAllocMap)
	allocs96f12068.Add(mem96f12068)

	var c_query_result_allocs *cgoAllocMap
	ref96f12068._query_result, c_query_result_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.QueryResult)), cgoAllocsUnknown
	allocs96f12068.Borrow(c_query_result_allocs)

	var c_is_owned_by_cpp_allocs *cgoAllocMap
	ref96f12068._is_owned_by_cpp, c_is_owned_by_cpp_allocs = (C._Bool)(x.IsOwnedByCpp), cgoAllocsUnknown
	allocs96f12068.Borrow(c_is_owned_by_cpp_allocs)

	x.ref96f12068 = ref96f12068
	x.allocs96f12068 = allocs96f12068
	return ref96f12068, allocs96f12068

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryResult) PassValue() (C.kuzu_query_result, *cgoAllocMap) {
	if x.ref96f12068 != nil {
		return *x.ref96f12068, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryResult) Deref() {
	if x.ref96f12068 == nil {
		return
	}
	x.QueryResult = (unsafe.Pointer)(unsafe.Pointer(x.ref96f12068._query_result))
	x.IsOwnedByCpp = (bool)(x.ref96f12068._is_owned_by_cpp)
}

// allocFlatTupleMemory allocates memory for type C.kuzu_flat_tuple in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFlatTupleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFlatTupleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFlatTupleValue = unsafe.Sizeof([1]C.kuzu_flat_tuple{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FlatTuple) Ref() *C.kuzu_flat_tuple {
	if x == nil {
		return nil
	}
	return x.ref9d13df43
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FlatTuple) Free() {
	if x != nil && x.allocs9d13df43 != nil {
		x.allocs9d13df43.(*cgoAllocMap).Free()
		x.ref9d13df43 = nil
	}
}

// NewFlatTupleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFlatTupleRef(ref unsafe.Pointer) *FlatTuple {
	if ref == nil {
		return nil
	}
	obj := new(FlatTuple)
	obj.ref9d13df43 = (*C.kuzu_flat_tuple)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FlatTuple) PassRef() (*C.kuzu_flat_tuple, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9d13df43 != nil {
		return x.ref9d13df43, nil
	}
	mem9d13df43 := allocFlatTupleMemory(1)
	ref9d13df43 := (*C.kuzu_flat_tuple)(mem9d13df43)
	allocs9d13df43 := new(cgoAllocMap)
	allocs9d13df43.Add(mem9d13df43)

	var c_flat_tuple_allocs *cgoAllocMap
	ref9d13df43._flat_tuple, c_flat_tuple_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.FlatTuple)), cgoAllocsUnknown
	allocs9d13df43.Borrow(c_flat_tuple_allocs)

	x.ref9d13df43 = ref9d13df43
	x.allocs9d13df43 = allocs9d13df43
	return ref9d13df43, allocs9d13df43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FlatTuple) PassValue() (C.kuzu_flat_tuple, *cgoAllocMap) {
	if x.ref9d13df43 != nil {
		return *x.ref9d13df43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FlatTuple) Deref() {
	if x.ref9d13df43 == nil {
		return
	}
	x.FlatTuple = (unsafe.Pointer)(unsafe.Pointer(x.ref9d13df43._flat_tuple))
}

// allocLogicalTypeMemory allocates memory for type C.kuzu_logical_type in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLogicalTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLogicalTypeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLogicalTypeValue = unsafe.Sizeof([1]C.kuzu_logical_type{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LogicalType) Ref() *C.kuzu_logical_type {
	if x == nil {
		return nil
	}
	return x.refbd1fd0f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LogicalType) Free() {
	if x != nil && x.allocsbd1fd0f6 != nil {
		x.allocsbd1fd0f6.(*cgoAllocMap).Free()
		x.refbd1fd0f6 = nil
	}
}

// NewLogicalTypeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLogicalTypeRef(ref unsafe.Pointer) *LogicalType {
	if ref == nil {
		return nil
	}
	obj := new(LogicalType)
	obj.refbd1fd0f6 = (*C.kuzu_logical_type)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LogicalType) PassRef() (*C.kuzu_logical_type, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd1fd0f6 != nil {
		return x.refbd1fd0f6, nil
	}
	membd1fd0f6 := allocLogicalTypeMemory(1)
	refbd1fd0f6 := (*C.kuzu_logical_type)(membd1fd0f6)
	allocsbd1fd0f6 := new(cgoAllocMap)
	allocsbd1fd0f6.Add(membd1fd0f6)

	var c_data_type_allocs *cgoAllocMap
	refbd1fd0f6._data_type, c_data_type_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.DataType)), cgoAllocsUnknown
	allocsbd1fd0f6.Borrow(c_data_type_allocs)

	x.refbd1fd0f6 = refbd1fd0f6
	x.allocsbd1fd0f6 = allocsbd1fd0f6
	return refbd1fd0f6, allocsbd1fd0f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LogicalType) PassValue() (C.kuzu_logical_type, *cgoAllocMap) {
	if x.refbd1fd0f6 != nil {
		return *x.refbd1fd0f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LogicalType) Deref() {
	if x.refbd1fd0f6 == nil {
		return
	}
	x.DataType = (unsafe.Pointer)(unsafe.Pointer(x.refbd1fd0f6._data_type))
}

// allocValueMemory allocates memory for type C.kuzu_value in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValueValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValueValue = unsafe.Sizeof([1]C.kuzu_value{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Value) Ref() *C.kuzu_value {
	if x == nil {
		return nil
	}
	return x.refd5f476b4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Value) Free() {
	if x != nil && x.allocsd5f476b4 != nil {
		x.allocsd5f476b4.(*cgoAllocMap).Free()
		x.refd5f476b4 = nil
	}
}

// NewValueRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValueRef(ref unsafe.Pointer) *Value {
	if ref == nil {
		return nil
	}
	obj := new(Value)
	obj.refd5f476b4 = (*C.kuzu_value)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Value) PassRef() (*C.kuzu_value, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd5f476b4 != nil {
		return x.refd5f476b4, nil
	}
	memd5f476b4 := allocValueMemory(1)
	refd5f476b4 := (*C.kuzu_value)(memd5f476b4)
	allocsd5f476b4 := new(cgoAllocMap)
	allocsd5f476b4.Add(memd5f476b4)

	var c_value_allocs *cgoAllocMap
	refd5f476b4._value, c_value_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Value)), cgoAllocsUnknown
	allocsd5f476b4.Borrow(c_value_allocs)

	var c_is_owned_by_cpp_allocs *cgoAllocMap
	refd5f476b4._is_owned_by_cpp, c_is_owned_by_cpp_allocs = (C._Bool)(x.IsOwnedByCpp), cgoAllocsUnknown
	allocsd5f476b4.Borrow(c_is_owned_by_cpp_allocs)

	x.refd5f476b4 = refd5f476b4
	x.allocsd5f476b4 = allocsd5f476b4
	return refd5f476b4, allocsd5f476b4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Value) PassValue() (C.kuzu_value, *cgoAllocMap) {
	if x.refd5f476b4 != nil {
		return *x.refd5f476b4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Value) Deref() {
	if x.refd5f476b4 == nil {
		return
	}
	x.Value = (unsafe.Pointer)(unsafe.Pointer(x.refd5f476b4._value))
	x.IsOwnedByCpp = (bool)(x.refd5f476b4._is_owned_by_cpp)
}

// allocInternalIdTMemory allocates memory for type C.kuzu_internal_id_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInternalIdTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInternalIdTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInternalIdTValue = unsafe.Sizeof([1]C.kuzu_internal_id_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InternalIdT) Ref() *C.kuzu_internal_id_t {
	if x == nil {
		return nil
	}
	return x.ref2387636b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InternalIdT) Free() {
	if x != nil && x.allocs2387636b != nil {
		x.allocs2387636b.(*cgoAllocMap).Free()
		x.ref2387636b = nil
	}
}

// NewInternalIdTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInternalIdTRef(ref unsafe.Pointer) *InternalIdT {
	if ref == nil {
		return nil
	}
	obj := new(InternalIdT)
	obj.ref2387636b = (*C.kuzu_internal_id_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InternalIdT) PassRef() (*C.kuzu_internal_id_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2387636b != nil {
		return x.ref2387636b, nil
	}
	mem2387636b := allocInternalIdTMemory(1)
	ref2387636b := (*C.kuzu_internal_id_t)(mem2387636b)
	allocs2387636b := new(cgoAllocMap)
	allocs2387636b.Add(mem2387636b)

	var ctable_id_allocs *cgoAllocMap
	ref2387636b.table_id, ctable_id_allocs = (C.uint64_t)(x.TableId), cgoAllocsUnknown
	allocs2387636b.Borrow(ctable_id_allocs)

	var coffset_allocs *cgoAllocMap
	ref2387636b.offset, coffset_allocs = (C.uint64_t)(x.Offset), cgoAllocsUnknown
	allocs2387636b.Borrow(coffset_allocs)

	x.ref2387636b = ref2387636b
	x.allocs2387636b = allocs2387636b
	return ref2387636b, allocs2387636b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InternalIdT) PassValue() (C.kuzu_internal_id_t, *cgoAllocMap) {
	if x.ref2387636b != nil {
		return *x.ref2387636b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InternalIdT) Deref() {
	if x.ref2387636b == nil {
		return
	}
	x.TableId = (uint64)(x.ref2387636b.table_id)
	x.Offset = (uint64)(x.ref2387636b.offset)
}

// allocDateTMemory allocates memory for type C.kuzu_date_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDateTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDateTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDateTValue = unsafe.Sizeof([1]C.kuzu_date_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DateT) Ref() *C.kuzu_date_t {
	if x == nil {
		return nil
	}
	return x.refab8f78a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DateT) Free() {
	if x != nil && x.allocsab8f78a2 != nil {
		x.allocsab8f78a2.(*cgoAllocMap).Free()
		x.refab8f78a2 = nil
	}
}

// NewDateTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDateTRef(ref unsafe.Pointer) *DateT {
	if ref == nil {
		return nil
	}
	obj := new(DateT)
	obj.refab8f78a2 = (*C.kuzu_date_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DateT) PassRef() (*C.kuzu_date_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refab8f78a2 != nil {
		return x.refab8f78a2, nil
	}
	memab8f78a2 := allocDateTMemory(1)
	refab8f78a2 := (*C.kuzu_date_t)(memab8f78a2)
	allocsab8f78a2 := new(cgoAllocMap)
	allocsab8f78a2.Add(memab8f78a2)

	var cdays_allocs *cgoAllocMap
	refab8f78a2.days, cdays_allocs = (C.int32_t)(x.Days), cgoAllocsUnknown
	allocsab8f78a2.Borrow(cdays_allocs)

	x.refab8f78a2 = refab8f78a2
	x.allocsab8f78a2 = allocsab8f78a2
	return refab8f78a2, allocsab8f78a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DateT) PassValue() (C.kuzu_date_t, *cgoAllocMap) {
	if x.refab8f78a2 != nil {
		return *x.refab8f78a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DateT) Deref() {
	if x.refab8f78a2 == nil {
		return
	}
	x.Days = (int32)(x.refab8f78a2.days)
}

// allocTimestampNsTMemory allocates memory for type C.kuzu_timestamp_ns_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTimestampNsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTimestampNsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTimestampNsTValue = unsafe.Sizeof([1]C.kuzu_timestamp_ns_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TimestampNsT) Ref() *C.kuzu_timestamp_ns_t {
	if x == nil {
		return nil
	}
	return x.refe2f90830
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TimestampNsT) Free() {
	if x != nil && x.allocse2f90830 != nil {
		x.allocse2f90830.(*cgoAllocMap).Free()
		x.refe2f90830 = nil
	}
}

// NewTimestampNsTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTimestampNsTRef(ref unsafe.Pointer) *TimestampNsT {
	if ref == nil {
		return nil
	}
	obj := new(TimestampNsT)
	obj.refe2f90830 = (*C.kuzu_timestamp_ns_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TimestampNsT) PassRef() (*C.kuzu_timestamp_ns_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2f90830 != nil {
		return x.refe2f90830, nil
	}
	meme2f90830 := allocTimestampNsTMemory(1)
	refe2f90830 := (*C.kuzu_timestamp_ns_t)(meme2f90830)
	allocse2f90830 := new(cgoAllocMap)
	allocse2f90830.Add(meme2f90830)

	var cvalue_allocs *cgoAllocMap
	refe2f90830.value, cvalue_allocs = (C.int64_t)(x.Value), cgoAllocsUnknown
	allocse2f90830.Borrow(cvalue_allocs)

	x.refe2f90830 = refe2f90830
	x.allocse2f90830 = allocse2f90830
	return refe2f90830, allocse2f90830

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TimestampNsT) PassValue() (C.kuzu_timestamp_ns_t, *cgoAllocMap) {
	if x.refe2f90830 != nil {
		return *x.refe2f90830, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TimestampNsT) Deref() {
	if x.refe2f90830 == nil {
		return
	}
	x.Value = (int64)(x.refe2f90830.value)
}

// allocTimestampMsTMemory allocates memory for type C.kuzu_timestamp_ms_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTimestampMsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTimestampMsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTimestampMsTValue = unsafe.Sizeof([1]C.kuzu_timestamp_ms_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TimestampMsT) Ref() *C.kuzu_timestamp_ms_t {
	if x == nil {
		return nil
	}
	return x.reff04ca7de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TimestampMsT) Free() {
	if x != nil && x.allocsf04ca7de != nil {
		x.allocsf04ca7de.(*cgoAllocMap).Free()
		x.reff04ca7de = nil
	}
}

// NewTimestampMsTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTimestampMsTRef(ref unsafe.Pointer) *TimestampMsT {
	if ref == nil {
		return nil
	}
	obj := new(TimestampMsT)
	obj.reff04ca7de = (*C.kuzu_timestamp_ms_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TimestampMsT) PassRef() (*C.kuzu_timestamp_ms_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff04ca7de != nil {
		return x.reff04ca7de, nil
	}
	memf04ca7de := allocTimestampMsTMemory(1)
	reff04ca7de := (*C.kuzu_timestamp_ms_t)(memf04ca7de)
	allocsf04ca7de := new(cgoAllocMap)
	allocsf04ca7de.Add(memf04ca7de)

	var cvalue_allocs *cgoAllocMap
	reff04ca7de.value, cvalue_allocs = (C.int64_t)(x.Value), cgoAllocsUnknown
	allocsf04ca7de.Borrow(cvalue_allocs)

	x.reff04ca7de = reff04ca7de
	x.allocsf04ca7de = allocsf04ca7de
	return reff04ca7de, allocsf04ca7de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TimestampMsT) PassValue() (C.kuzu_timestamp_ms_t, *cgoAllocMap) {
	if x.reff04ca7de != nil {
		return *x.reff04ca7de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TimestampMsT) Deref() {
	if x.reff04ca7de == nil {
		return
	}
	x.Value = (int64)(x.reff04ca7de.value)
}

// allocTimestampSecTMemory allocates memory for type C.kuzu_timestamp_sec_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTimestampSecTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTimestampSecTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTimestampSecTValue = unsafe.Sizeof([1]C.kuzu_timestamp_sec_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TimestampSecT) Ref() *C.kuzu_timestamp_sec_t {
	if x == nil {
		return nil
	}
	return x.ref155229e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TimestampSecT) Free() {
	if x != nil && x.allocs155229e1 != nil {
		x.allocs155229e1.(*cgoAllocMap).Free()
		x.ref155229e1 = nil
	}
}

// NewTimestampSecTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTimestampSecTRef(ref unsafe.Pointer) *TimestampSecT {
	if ref == nil {
		return nil
	}
	obj := new(TimestampSecT)
	obj.ref155229e1 = (*C.kuzu_timestamp_sec_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TimestampSecT) PassRef() (*C.kuzu_timestamp_sec_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref155229e1 != nil {
		return x.ref155229e1, nil
	}
	mem155229e1 := allocTimestampSecTMemory(1)
	ref155229e1 := (*C.kuzu_timestamp_sec_t)(mem155229e1)
	allocs155229e1 := new(cgoAllocMap)
	allocs155229e1.Add(mem155229e1)

	var cvalue_allocs *cgoAllocMap
	ref155229e1.value, cvalue_allocs = (C.int64_t)(x.Value), cgoAllocsUnknown
	allocs155229e1.Borrow(cvalue_allocs)

	x.ref155229e1 = ref155229e1
	x.allocs155229e1 = allocs155229e1
	return ref155229e1, allocs155229e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TimestampSecT) PassValue() (C.kuzu_timestamp_sec_t, *cgoAllocMap) {
	if x.ref155229e1 != nil {
		return *x.ref155229e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TimestampSecT) Deref() {
	if x.ref155229e1 == nil {
		return
	}
	x.Value = (int64)(x.ref155229e1.value)
}

// allocTimestampTzTMemory allocates memory for type C.kuzu_timestamp_tz_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTimestampTzTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTimestampTzTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTimestampTzTValue = unsafe.Sizeof([1]C.kuzu_timestamp_tz_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TimestampTzT) Ref() *C.kuzu_timestamp_tz_t {
	if x == nil {
		return nil
	}
	return x.refd28c8444
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TimestampTzT) Free() {
	if x != nil && x.allocsd28c8444 != nil {
		x.allocsd28c8444.(*cgoAllocMap).Free()
		x.refd28c8444 = nil
	}
}

// NewTimestampTzTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTimestampTzTRef(ref unsafe.Pointer) *TimestampTzT {
	if ref == nil {
		return nil
	}
	obj := new(TimestampTzT)
	obj.refd28c8444 = (*C.kuzu_timestamp_tz_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TimestampTzT) PassRef() (*C.kuzu_timestamp_tz_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd28c8444 != nil {
		return x.refd28c8444, nil
	}
	memd28c8444 := allocTimestampTzTMemory(1)
	refd28c8444 := (*C.kuzu_timestamp_tz_t)(memd28c8444)
	allocsd28c8444 := new(cgoAllocMap)
	allocsd28c8444.Add(memd28c8444)

	var cvalue_allocs *cgoAllocMap
	refd28c8444.value, cvalue_allocs = (C.int64_t)(x.Value), cgoAllocsUnknown
	allocsd28c8444.Borrow(cvalue_allocs)

	x.refd28c8444 = refd28c8444
	x.allocsd28c8444 = allocsd28c8444
	return refd28c8444, allocsd28c8444

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TimestampTzT) PassValue() (C.kuzu_timestamp_tz_t, *cgoAllocMap) {
	if x.refd28c8444 != nil {
		return *x.refd28c8444, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TimestampTzT) Deref() {
	if x.refd28c8444 == nil {
		return
	}
	x.Value = (int64)(x.refd28c8444.value)
}

// allocTimestampTMemory allocates memory for type C.kuzu_timestamp_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTimestampTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTimestampTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTimestampTValue = unsafe.Sizeof([1]C.kuzu_timestamp_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TimestampT) Ref() *C.kuzu_timestamp_t {
	if x == nil {
		return nil
	}
	return x.ref232f4437
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TimestampT) Free() {
	if x != nil && x.allocs232f4437 != nil {
		x.allocs232f4437.(*cgoAllocMap).Free()
		x.ref232f4437 = nil
	}
}

// NewTimestampTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTimestampTRef(ref unsafe.Pointer) *TimestampT {
	if ref == nil {
		return nil
	}
	obj := new(TimestampT)
	obj.ref232f4437 = (*C.kuzu_timestamp_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TimestampT) PassRef() (*C.kuzu_timestamp_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref232f4437 != nil {
		return x.ref232f4437, nil
	}
	mem232f4437 := allocTimestampTMemory(1)
	ref232f4437 := (*C.kuzu_timestamp_t)(mem232f4437)
	allocs232f4437 := new(cgoAllocMap)
	allocs232f4437.Add(mem232f4437)

	var cvalue_allocs *cgoAllocMap
	ref232f4437.value, cvalue_allocs = (C.int64_t)(x.Value), cgoAllocsUnknown
	allocs232f4437.Borrow(cvalue_allocs)

	x.ref232f4437 = ref232f4437
	x.allocs232f4437 = allocs232f4437
	return ref232f4437, allocs232f4437

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TimestampT) PassValue() (C.kuzu_timestamp_t, *cgoAllocMap) {
	if x.ref232f4437 != nil {
		return *x.ref232f4437, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TimestampT) Deref() {
	if x.ref232f4437 == nil {
		return
	}
	x.Value = (int64)(x.ref232f4437.value)
}

// allocIntervalTMemory allocates memory for type C.kuzu_interval_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntervalTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntervalTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIntervalTValue = unsafe.Sizeof([1]C.kuzu_interval_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IntervalT) Ref() *C.kuzu_interval_t {
	if x == nil {
		return nil
	}
	return x.ref22729eeb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IntervalT) Free() {
	if x != nil && x.allocs22729eeb != nil {
		x.allocs22729eeb.(*cgoAllocMap).Free()
		x.ref22729eeb = nil
	}
}

// NewIntervalTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIntervalTRef(ref unsafe.Pointer) *IntervalT {
	if ref == nil {
		return nil
	}
	obj := new(IntervalT)
	obj.ref22729eeb = (*C.kuzu_interval_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IntervalT) PassRef() (*C.kuzu_interval_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22729eeb != nil {
		return x.ref22729eeb, nil
	}
	mem22729eeb := allocIntervalTMemory(1)
	ref22729eeb := (*C.kuzu_interval_t)(mem22729eeb)
	allocs22729eeb := new(cgoAllocMap)
	allocs22729eeb.Add(mem22729eeb)

	var cmonths_allocs *cgoAllocMap
	ref22729eeb.months, cmonths_allocs = (C.int32_t)(x.Months), cgoAllocsUnknown
	allocs22729eeb.Borrow(cmonths_allocs)

	var cdays_allocs *cgoAllocMap
	ref22729eeb.days, cdays_allocs = (C.int32_t)(x.Days), cgoAllocsUnknown
	allocs22729eeb.Borrow(cdays_allocs)

	var cmicros_allocs *cgoAllocMap
	ref22729eeb.micros, cmicros_allocs = (C.int64_t)(x.Micros), cgoAllocsUnknown
	allocs22729eeb.Borrow(cmicros_allocs)

	x.ref22729eeb = ref22729eeb
	x.allocs22729eeb = allocs22729eeb
	return ref22729eeb, allocs22729eeb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IntervalT) PassValue() (C.kuzu_interval_t, *cgoAllocMap) {
	if x.ref22729eeb != nil {
		return *x.ref22729eeb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IntervalT) Deref() {
	if x.ref22729eeb == nil {
		return
	}
	x.Months = (int32)(x.ref22729eeb.months)
	x.Days = (int32)(x.ref22729eeb.days)
	x.Micros = (int64)(x.ref22729eeb.micros)
}

// allocQuerySummaryMemory allocates memory for type C.kuzu_query_summary in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQuerySummaryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQuerySummaryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQuerySummaryValue = unsafe.Sizeof([1]C.kuzu_query_summary{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QuerySummary) Ref() *C.kuzu_query_summary {
	if x == nil {
		return nil
	}
	return x.ref97a5536
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QuerySummary) Free() {
	if x != nil && x.allocs97a5536 != nil {
		x.allocs97a5536.(*cgoAllocMap).Free()
		x.ref97a5536 = nil
	}
}

// NewQuerySummaryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQuerySummaryRef(ref unsafe.Pointer) *QuerySummary {
	if ref == nil {
		return nil
	}
	obj := new(QuerySummary)
	obj.ref97a5536 = (*C.kuzu_query_summary)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QuerySummary) PassRef() (*C.kuzu_query_summary, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref97a5536 != nil {
		return x.ref97a5536, nil
	}
	mem97a5536 := allocQuerySummaryMemory(1)
	ref97a5536 := (*C.kuzu_query_summary)(mem97a5536)
	allocs97a5536 := new(cgoAllocMap)
	allocs97a5536.Add(mem97a5536)

	var c_query_summary_allocs *cgoAllocMap
	ref97a5536._query_summary, c_query_summary_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.QuerySummary)), cgoAllocsUnknown
	allocs97a5536.Borrow(c_query_summary_allocs)

	x.ref97a5536 = ref97a5536
	x.allocs97a5536 = allocs97a5536
	return ref97a5536, allocs97a5536

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QuerySummary) PassValue() (C.kuzu_query_summary, *cgoAllocMap) {
	if x.ref97a5536 != nil {
		return *x.ref97a5536, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QuerySummary) Deref() {
	if x.ref97a5536 == nil {
		return
	}
	x.QuerySummary = (unsafe.Pointer)(unsafe.Pointer(x.ref97a5536._query_summary))
}

// allocInt128TMemory allocates memory for type C.kuzu_int128_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt128TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt128TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt128TValue = unsafe.Sizeof([1]C.kuzu_int128_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Int128T) Ref() *C.kuzu_int128_t {
	if x == nil {
		return nil
	}
	return x.reff96f3de2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Int128T) Free() {
	if x != nil && x.allocsf96f3de2 != nil {
		x.allocsf96f3de2.(*cgoAllocMap).Free()
		x.reff96f3de2 = nil
	}
}

// NewInt128TRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInt128TRef(ref unsafe.Pointer) *Int128T {
	if ref == nil {
		return nil
	}
	obj := new(Int128T)
	obj.reff96f3de2 = (*C.kuzu_int128_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Int128T) PassRef() (*C.kuzu_int128_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff96f3de2 != nil {
		return x.reff96f3de2, nil
	}
	memf96f3de2 := allocInt128TMemory(1)
	reff96f3de2 := (*C.kuzu_int128_t)(memf96f3de2)
	allocsf96f3de2 := new(cgoAllocMap)
	allocsf96f3de2.Add(memf96f3de2)

	var clow_allocs *cgoAllocMap
	reff96f3de2.low, clow_allocs = (C.uint64_t)(x.Low), cgoAllocsUnknown
	allocsf96f3de2.Borrow(clow_allocs)

	var chigh_allocs *cgoAllocMap
	reff96f3de2.high, chigh_allocs = (C.int64_t)(x.High), cgoAllocsUnknown
	allocsf96f3de2.Borrow(chigh_allocs)

	x.reff96f3de2 = reff96f3de2
	x.allocsf96f3de2 = allocsf96f3de2
	return reff96f3de2, allocsf96f3de2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Int128T) PassValue() (C.kuzu_int128_t, *cgoAllocMap) {
	if x.reff96f3de2 != nil {
		return *x.reff96f3de2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Int128T) Deref() {
	if x.reff96f3de2 == nil {
		return
	}
	x.Low = (uint64)(x.reff96f3de2.low)
	x.High = (int64)(x.reff96f3de2.high)
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSDatabase transforms a sliced Go data structure into plain C format.
func unpackArgSDatabase(x []Database) (unpacked *C.kuzu_database, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDatabaseMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_database)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_database)(h.Data)
	return
}

// packSDatabase reads sliced Go data structure out from plain C format.
func packSDatabase(v []Database, ptr0 *C.kuzu_database) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDatabaseValue]C.kuzu_database)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDatabaseRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSConnection transforms a sliced Go data structure into plain C format.
func unpackArgSConnection(x []Connection) (unpacked *C.kuzu_connection, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocConnectionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_connection)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_connection)(h.Data)
	return
}

// packSConnection reads sliced Go data structure out from plain C format.
func packSConnection(v []Connection, ptr0 *C.kuzu_connection) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfConnectionValue]C.kuzu_connection)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewConnectionRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPreparedStatement transforms a sliced Go data structure into plain C format.
func unpackArgSPreparedStatement(x []PreparedStatement) (unpacked *C.kuzu_prepared_statement, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPreparedStatementMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_prepared_statement)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_prepared_statement)(h.Data)
	return
}

// packSPreparedStatement reads sliced Go data structure out from plain C format.
func packSPreparedStatement(v []PreparedStatement, ptr0 *C.kuzu_prepared_statement) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPreparedStatementValue]C.kuzu_prepared_statement)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPreparedStatementRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSValue transforms a sliced Go data structure into plain C format.
func unpackArgSValue(x []Value) (unpacked *C.kuzu_value, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocValueMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_value)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_value)(h.Data)
	return
}

// packSValue reads sliced Go data structure out from plain C format.
func packSValue(v []Value, ptr0 *C.kuzu_value) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfValueValue]C.kuzu_value)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewValueRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSQueryResult transforms a sliced Go data structure into plain C format.
func unpackArgSQueryResult(x []QueryResult) (unpacked *C.kuzu_query_result, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocQueryResultMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_query_result)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_query_result)(h.Data)
	return
}

// packSQueryResult reads sliced Go data structure out from plain C format.
func packSQueryResult(v []QueryResult, ptr0 *C.kuzu_query_result) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQueryResultValue]C.kuzu_query_result)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQueryResultRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFlatTuple transforms a sliced Go data structure into plain C format.
func unpackArgSFlatTuple(x []FlatTuple) (unpacked *C.kuzu_flat_tuple, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocFlatTupleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_flat_tuple)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_flat_tuple)(h.Data)
	return
}

// packSFlatTuple reads sliced Go data structure out from plain C format.
func packSFlatTuple(v []FlatTuple, ptr0 *C.kuzu_flat_tuple) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFlatTupleValue]C.kuzu_flat_tuple)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFlatTupleRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLogicalType transforms a sliced Go data structure into plain C format.
func unpackArgSLogicalType(x []LogicalType) (unpacked *C.kuzu_logical_type, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocLogicalTypeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_logical_type)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_logical_type)(h.Data)
	return
}

// packSLogicalType reads sliced Go data structure out from plain C format.
func packSLogicalType(v []LogicalType, ptr0 *C.kuzu_logical_type) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLogicalTypeValue]C.kuzu_logical_type)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLogicalTypeRef(unsafe.Pointer(&ptr1))
	}
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// unpackArgSQuerySummary transforms a sliced Go data structure into plain C format.
func unpackArgSQuerySummary(x []QuerySummary) (unpacked *C.kuzu_query_summary, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocQuerySummaryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.kuzu_query_summary)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.kuzu_query_summary)(h.Data)
	return
}

// packSQuerySummary reads sliced Go data structure out from plain C format.
func packSQuerySummary(v []QuerySummary, ptr0 *C.kuzu_query_summary) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfQuerySummaryValue]C.kuzu_query_summary)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewQuerySummaryRef(unsafe.Pointer(&ptr1))
	}
}
